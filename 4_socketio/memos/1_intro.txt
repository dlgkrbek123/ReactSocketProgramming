---------------------------------------------------------------------------------

socket.io의 특징

1. 크로스 브라우징 => 구버전 브라우져의 경우 웹소켓이 아닌 롱 폴링 방식을 사용
2. 다양한 서버사이드 언어를 지원
3. 자동 연결기능 => 클라이언트 서버간의 연결에 문제 발생시 재연결 시도
4. 간편하게 데이터를 전송가능
5. 채널 / 방단위 기능을 제공
6. 클라나 서버가 socket.io로 구성되어 있다면 반대쪽도 socket.io로 구성되어야 함

---------------------------------------------------------------------------------

이벤트
  connection  : 클라이언트 연결
  disconnect  : 클라이언트 연결 해제
  
  on          : 이벤트 연결
  emit        : 이벤트 생성

  socket.join : 클라이언트에 방을 할당
  sockets.in() / sockets.to() : 클라이언트를 선택

---------------------------------------------------------------------------------

채널
  private : 1대1 통신
  => io.sockets.to(id).emit()

  public   : 송신자를 포함한 전부
  => io.sockets.emit()

  broadcast : 송신자를 제외한 전부
  => socket.broadcast.emit()

---------------------------------------------------------------------------------

룸
=> 단체대화방
=> private 채널은 내부적으로 룸이라는 기능이 적용되었음

---------------------------------------------------------------------------------

네임스페이스
=> 서비스를 내부적으로 구분할 수 있는 공간
=> 네임스페이스는 룸의 상위 버전
=> 네임스페이스를 여러개 연결하면 소켓이 여러개인건가?
  => 아니다 소켓은 도메인별로 하나만 생성하며 패킷을 알맞게 전송하게 한다.

!! 서버 라우트별로 섹션을 나눈다 !! 
  /goods
  /user


!! 네임스페이스에 접속한 소켓 객체 !!
!! autoConnect를 false로 설정해서 socket.connect()를 호출해서 수동 연결 !!
import { io } from "socket.io-client";

export const socketGoods = io("http://localhost:5000/goods", {
    autoConnect: false,
});
export const socketUser = io("http://localhost:5000/user", {
    autoConnect: false,
});

---------------------------------------------------------------------------------

CORS
=> cross origin resource sharing
=> 웹페이지가 다른 추철의 도메인에 자유롭게 데이터를 주고받을 수 있도록 허용하는 정책
=> SOP라는 보안정책에 의한 브라우저의 제약을 완화 
   (같은 출처끼리만 데이터를 교환가능하게 제한)
    => 프로토콜, 도메인, 포트가 모두 일치해야만 데이터 교환 가능
    => CSRF같은 보안 위협으로부터 서버의 리소스를 보호하기 위함

=> 허가된 도메인들에서는 데이터에 접근 가능하게 설정
=> 서버에서 응답 헤더에 정책을 설정, 브라우져에 의해 검사됨

---------------------------------------------------------------------------------